#+TITLE: Source Code Structure generator
#+AUTHOR: VLEAD
#+DATE:  [2016-12-15 Thu]
#+SETUPFILE: ../../org-templates/level-2.org
#+TAGS: boilerplate(b)
#+EXCLUDE_TAGS: boilerplate
#+OPTIONS: ^:nil

* Introduction
  This document illustrates mechanism to add ajax hooks into empty html files that are generated by
  platform specific skeletal structure generator(ex: openEdX). To make ajax call to content
  server resource-ids are needed which are requested from Lab Data  Services. 
  This code takes 2 inputs
  1) lab Id
  2) Path to Directory which holds all empty html files


* Main Process
  Input is lab-Id and path to directory with html files.
  Requested detailed labSpec(with Resource-ids) from LDS is expected to be of following format
#+BEGIN_EXAMPLE
{
        "course": {"org": "iiith","id": "cse24", "display_name": "Natural Language Processing"},
        "overview": "Natural Language Processing Lab",
        "experiments": [
                         {"id": "E99709", "name": "Word Analysis",
                         "subsections": [{"Introduction": "res-id2"},
                                         {"Theory": "res-id3"},
                                         {"Objective": "res-id4"},
                                         {"Experiment": "res-id5"},
                                         {"Quizzes": "res-id6"},
                                         {"Procedure": "res-id7"},
                                         {"Further Readings": "res-id8"},
                                         {"Feedback": "res-id9"}
                                         ]}]
}

#+END_EXAMPLE

Main process requests LDS-server for detailed lab specification file, which has
information about resource-ids as shown above in example.
Then a search is conducted to align resource-files(HTML files) to a specific
resource-id, with help of HTML filename and detailed lab spec file.

#+NAME: main_process
#+BEGIN_SRC python
if __name__ == '__main__':
    if len(sys.argv) == 3:
        lab_id = sys.argv[1]
        html_dir_path = sys.argv[2]
        newURL = URL + lab_id
        detailed_lab_spec = send_request(newURL)
        file_map = align_file_to_id(detailed_lab_spec, html_dir_path)
    else:
        print "Usage: python <fetch-content.py> <lab-Id> <DirPath to all empty HTML files>"

#+END_SRC


* Implementation

** Send Request
Sends HTTP request to server and fetches json content
#+NAME: send_request
#+BEGIN_SRC python
def send_request(url):
    try:
        jstr = requests.get(url)
        j = json.loads(jstr.content)
        return j
    except Exception as error:
        print ('Error: '+str(error))
       

#+END_SRC


** Edit Name
   All non-alphanumeric characters are dropped and spaces are replaced with
   hyphen
#+NAME: sanitize_name
#+BEGIN_SRC python
def edit_name(name):
    name = name.lower()
    new_name = re.sub(r'[^a-zA-Z0-9\s+-]', '', name)
    new_name = new_name.strip()
    final_name = re.sub('\s+', '-', new_name)
    return final_name

#+END_SRC 


** Align Html File to Resource-Id
   This function aligns html file and its proper resource-id
#+NAME: align_file_to_id
#+BEGIN_SRC python
def align_file_to_id(labspec, html_dir_path):
    all_files = os.listdir(html_dir_path)
    html_files = [f for f in all_files if 'l.html' in f]
    exps = labspec.get('experiments')
    for f in html_files:
        ref = f.replace('_', ' ')
        for e in exps:
            exp_name = e.get('name')
            subsections = e.get('subsections')
            for k in subsections:
                sub_sec_name = k.keys()[0]
                res_id = k.values()[0]
                if sub_sec_name in ref and exp_name in ref:
                    edit_html_file(f, html_dir_path, res_id, sub_sec_name)

#+END_SRC



** Edit Html File
   This function edits html file, adds ajax call and proper html tags to hold
   the retrieved data
   Server-side script must have '/req/<Id>' route which will serve absolute
   path of res-Id.  
   HTML content being written has javascript part that makes ajax call
   currently to http://localhost , this should point to content server which
   will respond with absolute path resource location for requested resource-id
   (content-server)
#+NAME: edit_html_file
#+BEGIN_SRC python
def edit_html_file(file_name, html_dir_path, res_id, sub_sec_name):
    file_path = os.path.join(html_dir_path,file_name)
    content_file_name = edit_name(file_name)
    sname = edit_name(sub_sec_name)
    final_file_name = res_id+'-'+sname+'.html'
    try:
        fp = open(file_path, 'w+')
        newUrl = URL + 'req/' + res_id
        r = requests.get(newUrl)
        abs_path = r.content
        html_boiler_plate = """
<!DOCTYPE html>
<html>
<script>
function loadDoc() {
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
if (this.readyState == 4 && this.status == 200) {

}
};
var url = "%sreq/%s"
xhttp.open("GET", url, true);
xhttp.send();
}
</script>
<body onload="loadDoc()">
<object width="4000" height="4000" data="http://localhost/%s">
</object>
</body>
</html>""" % (URL, res_id ,final_file_name)
        sp = BeautifulSoup(html_boiler_plate)
        html_boiler_plate = sp.prettify()
        fp.write(html_boiler_plate)
        fp.close()
    except Exception as error:
        print ('Error: '+str(error))

#+END_SRC



* Infra                                                         :boilerplate:

** sources
*** Imports 
#+name: imports_for_sources
#+BEGIN_SRC python
# -*- coding: utf-8 -*-
import sys, requests, json, os, re
from config.config import URL
from bs4 import BeautifulSoup

#+end_src


* Tangling                                                      :boilerplate:

** sources
#+BEGIN_SRC python :tangle fetch_content.py :eval no :noweb yes
<<imports_for_sources>>
<<send_request>>
<<sanitize_name>>
<<edit_html_file>>
<<align_file_to_id>>
<<main_process>>
#+end_src


